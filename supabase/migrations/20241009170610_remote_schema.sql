SET statement_timeout = 0;

SET lock_timeout = 0;

SET idle_in_transaction_session_timeout = 0;

SET client_encoding = 'UTF8';

SET standard_conforming_strings = ON;

SELECT
    pg_catalog.set_config('search_path', '', FALSE);

SET check_function_bodies = FALSE;

SET xmloption = content;

SET client_min_messages = warning;

SET row_security = OFF;

CREATE EXTENSION IF NOT EXISTS "pgsodium" WITH SCHEMA "pgsodium";

COMMENT ON SCHEMA "public" IS 'standard public schema';

CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";

CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "pgjwt" WITH SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";

CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";

SET default_tablespace = '';

SET default_table_access_method = "heap";

CREATE TABLE IF NOT EXISTS "public"."parts"(
    "id" bigint GENERATED BY DEFAULT AS IDENTITY,
    "uuid" uuid DEFAULT gen_random_uuid() NOT NULL,
    "name" text NOT NULL,
    "quantity" integer NOT NULL,
    "price" numeric(10, 2) NOT NULL
);

ALTER TABLE "public"."parts" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."product_parts"(
    "id" bigint GENERATED BY DEFAULT AS IDENTITY,
    "uuid" uuid DEFAULT gen_random_uuid() NOT NULL,
    "product_id" bigint NOT NULL,
    "part_id" bigint NOT NULL,
    "quantity" numeric(10, 4) NOT NULL
);

ALTER TABLE "public"."product_parts" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."products"(
    "id" bigint GENERATED BY DEFAULT AS IDENTITY,
    "uuid" uuid DEFAULT gen_random_uuid() NOT NULL,
    "name" text NOT NULL,
    "quantity" integer NOT NULL,
    "price" numeric(10, 2) NOT NULL
);

ALTER TABLE "public"."products" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."purchases"(
    "id" bigint GENERATED BY DEFAULT AS IDENTITY,
    "uuid" uuid DEFAULT gen_random_uuid() NOT NULL,
    "total_cost" numeric(10, 2) NOT NULL,
    "quantity" integer NOT NULL,
    "purchase_date" timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);

ALTER TABLE "public"."purchases" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."purchase_products"(
    "id" bigint GENERATED BY DEFAULT AS IDENTITY,
    "uuid" uuid DEFAULT gen_random_uuid() NOT NULL,
    "purchase_id" bigint,
    "product_id" bigint,
    "quantity" numeric(10, 4) NOT NULL
);

ALTER TABLE "public"."purchase_products" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."purchase_parts"(
    "id" bigint GENERATED BY DEFAULT AS IDENTITY,
    "uuid" uuid DEFAULT gen_random_uuid() NOT NULL,
    "purchase_id" bigint,
    "part_id" bigint,
    "quantity" numeric(10, 4) NOT NULL
);

ALTER TABLE "public"."purchase_parts" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."sales"(
    "id" bigint GENERATED BY DEFAULT AS IDENTITY,
    "uuid" uuid DEFAULT gen_random_uuid() NOT NULL,
    "total_cost" numeric(10, 2) NOT NULL,
    "sale_date" timestamp with time zone DEFAULT now()
);

ALTER TABLE "public"."sales" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."sale_products"(
    "id" bigint GENERATED BY DEFAULT AS IDENTITY,
    "uuid" uuid DEFAULT gen_random_uuid() NOT NULL,
    "sale_id" bigint,
    "product_id" bigint,
    "quantity" integer NOT NULL,
    "price" numeric(10, 2) NOT NULL
);

ALTER TABLE "public"."sale_products" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."stock"(
    "id" bigint GENERATED BY DEFAULT AS IDENTITY,
    "uuid" uuid DEFAULT gen_random_uuid() NOT NULL,
    "product_id" bigint NOT NULL,
    "location_id" bigint NOT NULL,
    "quantity" integer NOT NULL
);

ALTER TABLE "public"."stock" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."stock_locations"(
    "id" bigint GENERATED BY DEFAULT AS IDENTITY,
    "uuid" uuid DEFAULT gen_random_uuid() NOT NULL,
    "country" text NOT NULL
);

ALTER TABLE "public"."stock_locations" OWNER TO "postgres";

ALTER TABLE ONLY "public"."parts"
    ADD CONSTRAINT "parts_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."product_parts"
    ADD CONSTRAINT "product_parts_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."products"
    ADD CONSTRAINT "products_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."purchases"
    ADD CONSTRAINT "purchases_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."purchase_products"
    ADD CONSTRAINT "purchase_products_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."purchase_parts"
    ADD CONSTRAINT "purchase_parts_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."sale_products"
    ADD CONSTRAINT "sale_products_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."sales"
    ADD CONSTRAINT "sales_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."stock_locations"
    ADD CONSTRAINT "stock_locations_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."stock"
    ADD CONSTRAINT "stock_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."product_parts"
    ADD CONSTRAINT "product_parts_part_id_fkey" FOREIGN KEY ("part_id") REFERENCES "public"."parts"("id");

ALTER TABLE ONLY "public"."product_parts"
    ADD CONSTRAINT "product_parts_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("id");

ALTER TABLE ONLY "public"."purchase_products"
    ADD CONSTRAINT "purchase_products_purchase_id_fkey" FOREIGN KEY ("purchase_id") REFERENCES "public"."purchases"("id");

ALTER TABLE ONLY "public"."purchase_products"
    ADD CONSTRAINT "purchase_products_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("id");

ALTER TABLE ONLY "public"."purchase_parts"
    ADD CONSTRAINT "purchase_parts_purchase_id_fkey" FOREIGN KEY ("purchase_id") REFERENCES "public"."purchases"("id");

ALTER TABLE ONLY "public"."purchase_parts"
    ADD CONSTRAINT "purchase_parts_part_id_fkey" FOREIGN KEY ("part_id") REFERENCES "public"."parts"("id");

ALTER TABLE ONLY "public"."sale_products"
    ADD CONSTRAINT "sale_products_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("id");

ALTER TABLE ONLY "public"."sale_products"
    ADD CONSTRAINT "sale_products_sale_id_fkey" FOREIGN KEY ("sale_id") REFERENCES "public"."sales"("id");

ALTER TABLE ONLY "public"."stock"
    ADD CONSTRAINT "stock_location_id_fkey" FOREIGN KEY ("location_id") REFERENCES "public"."stock_locations"("id");

ALTER TABLE ONLY "public"."stock"
    ADD CONSTRAINT "stock_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("id");

ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";

GRANT USAGE ON SCHEMA "public" TO "postgres";

GRANT USAGE ON SCHEMA "public" TO "anon";

GRANT USAGE ON SCHEMA "public" TO "authenticated";

GRANT USAGE ON SCHEMA "public" TO "service_role";

GRANT ALL ON TABLE "public"."parts" TO "anon";

GRANT ALL ON TABLE "public"."parts" TO "authenticated";

GRANT ALL ON TABLE "public"."parts" TO "service_role";

GRANT ALL ON SEQUENCE "public"."parts_id_seq"
    TO "anon";

GRANT ALL ON SEQUENCE "public"."parts_id_seq"
    TO "authenticated";

GRANT ALL ON SEQUENCE "public"."parts_id_seq"
    TO "service_role";

GRANT ALL ON TABLE "public"."product_parts" TO "anon";

GRANT ALL ON TABLE "public"."product_parts" TO "authenticated";

GRANT ALL ON TABLE "public"."product_parts" TO "service_role";

GRANT ALL ON TABLE "public"."products" TO "anon";

GRANT ALL ON TABLE "public"."products" TO "authenticated";

GRANT ALL ON TABLE "public"."products" TO "service_role";

GRANT ALL ON SEQUENCE "public"."products_id_seq"
    TO "anon";

GRANT ALL ON SEQUENCE "public"."products_id_seq"
    TO "authenticated";

GRANT ALL ON SEQUENCE "public"."products_id_seq"
    TO "service_role";

GRANT ALL ON TABLE "public"."purchases" TO "anon";

GRANT ALL ON TABLE "public"."purchases" TO "authenticated";

GRANT ALL ON TABLE "public"."purchases" TO "service_role";

GRANT ALL ON SEQUENCE "public"."purchases_id_seq"
    TO "anon";

GRANT ALL ON SEQUENCE "public"."purchases_id_seq"
    TO "authenticated";

GRANT ALL ON SEQUENCE "public"."purchases_id_seq"
    TO "service_role";

GRANT ALL ON TABLE "public"."purchase_products" TO "anon";

GRANT ALL ON TABLE "public"."purchase_products" TO "authenticated";

GRANT ALL ON TABLE "public"."purchase_products" TO "service_role";

GRANT ALL ON SEQUENCE "public"."purchase_products_id_seq"
    TO "anon";

GRANT ALL ON SEQUENCE "public"."purchase_products_id_seq"
    TO "authenticated";

GRANT ALL ON SEQUENCE "public"."purchase_products_id_seq"
    TO "service_role";

GRANT ALL ON TABLE "public"."purchase_parts" TO "anon";

GRANT ALL ON TABLE "public"."purchase_parts" TO "authenticated";

GRANT ALL ON TABLE "public"."purchase_parts" TO "service_role";

GRANT ALL ON SEQUENCE "public"."purchase_parts_id_seq"
    TO "anon";

GRANT ALL ON SEQUENCE "public"."purchase_parts_id_seq"
    TO "authenticated";

GRANT ALL ON SEQUENCE "public"."purchase_parts_id_seq"
    TO "service_role";

GRANT ALL ON TABLE "public"."sales" TO "anon";

GRANT ALL ON TABLE "public"."sales" TO "authenticated";

GRANT ALL ON TABLE "public"."sales" TO "service_role";

GRANT ALL ON SEQUENCE "public"."sales_id_seq"
    TO "anon";

GRANT ALL ON SEQUENCE "public"."sales_id_seq"
    TO "authenticated";

GRANT ALL ON SEQUENCE "public"."sales_id_seq"
    TO "service_role";

GRANT ALL ON TABLE "public"."sale_products" TO "anon";

GRANT ALL ON TABLE "public"."sale_products" TO "authenticated";

GRANT ALL ON TABLE "public"."sale_products" TO "service_role";

GRANT ALL ON SEQUENCE "public"."sale_products_id_seq"
    TO "anon";

GRANT ALL ON SEQUENCE "public"."sale_products_id_seq"
    TO "authenticated";

GRANT ALL ON SEQUENCE "public"."sale_products_id_seq"
    TO "service_role";

GRANT ALL ON TABLE "public"."stock" TO "anon";

GRANT ALL ON TABLE "public"."stock" TO "authenticated";

GRANT ALL ON TABLE "public"."stock" TO "service_role";

GRANT ALL ON SEQUENCE "public"."stock_id_seq"
    TO "anon";

GRANT ALL ON SEQUENCE "public"."stock_id_seq"
    TO "authenticated";

GRANT ALL ON SEQUENCE "public"."stock_id_seq"
    TO "service_role";

GRANT ALL ON TABLE "public"."stock_locations" TO "anon";

GRANT ALL ON TABLE "public"."stock_locations" TO "authenticated";

GRANT ALL ON TABLE "public"."stock_locations" TO "service_role";

GRANT ALL ON SEQUENCE "public"."stock_locations_id_seq"
    TO "anon";

GRANT ALL ON SEQUENCE "public"."stock_locations_id_seq"
    TO "authenticated";

GRANT ALL ON SEQUENCE "public"."stock_locations_id_seq"
    TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";

RESET ALL;

-- Add unique constraints for uuid columns
ALTER TABLE ONLY "public"."parts"
    ADD CONSTRAINT "parts_uuid_key" UNIQUE ("uuid");

ALTER TABLE ONLY "public"."product_parts"
    ADD CONSTRAINT "product_parts_uuid_key" UNIQUE ("uuid");

ALTER TABLE ONLY "public"."products"
    ADD CONSTRAINT "products_uuid_key" UNIQUE ("uuid");

ALTER TABLE ONLY "public"."purchases"
    ADD CONSTRAINT "purchases_uuid_key" UNIQUE ("uuid");

ALTER TABLE ONLY "public"."purchase_products"
    ADD CONSTRAINT "purchase_products_uuid_key" UNIQUE ("uuid");

ALTER TABLE ONLY "public"."purchase_parts"
    ADD CONSTRAINT "purchase_parts_uuid_key" UNIQUE ("uuid");

ALTER TABLE ONLY "public"."sales"
    ADD CONSTRAINT "sales_uuid_key" UNIQUE ("uuid");

ALTER TABLE ONLY "public"."sale_products"
    ADD CONSTRAINT "sale_products_uuid_key" UNIQUE ("uuid");

ALTER TABLE ONLY "public"."stock"
    ADD CONSTRAINT "stock_uuid_key" UNIQUE ("uuid");

ALTER TABLE ONLY "public"."stock_locations"
    ADD CONSTRAINT "stock_locations_uuid_key" UNIQUE ("uuid");

-- Function to upsert product and manage product parts
CREATE OR REPLACE FUNCTION public.upsert_product_with_parts(p_name text, p_quantity integer, p_price numeric(10, 2), p_product_parts jsonb, p_id bigint DEFAULT NULL)
    RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_product_id bigint;
    part jsonb;
BEGIN
    -- Input validation
    IF p_name IS NULL OR p_quantity IS NULL OR p_price IS NULL OR p_product_parts IS NULL THEN
        RAISE EXCEPTION 'All parameters except p_id must not be null';
    END IF;
    -- Upsert the product
    IF p_id IS NULL THEN
        -- Insert new product
        INSERT INTO public.products(name, quantity, price)
            VALUES (p_name, p_quantity, p_price)
        RETURNING
            id INTO v_product_id;
    ELSE
        -- Update existing product
        UPDATE
            public.products
        SET
            name = p_name,
            quantity = p_quantity,
            price = p_price
        WHERE
            id = p_id
        RETURNING
            id INTO v_product_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'No product found with id %', p_id;
        END IF;
    END IF;
    -- Remove existing product parts for this product
    DELETE FROM public.product_parts
    WHERE product_id = v_product_id;
    -- Insert new product parts
    FOR part IN
    SELECT
        *
    FROM
        jsonb_array_elements(p_product_parts)
        LOOP
            BEGIN
                INSERT INTO public.product_parts(product_id, part_id, quantity)
                    VALUES (v_product_id,(part ->> 'part_id')::bigint,(part ->> 'quantity')::numeric(10, 4));
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE EXCEPTION 'Error inserting part: %', SQLERRM;
            END;
    END LOOP;
    RETURN v_product_id;
END;

$$;

-- Grant execute permission on the function
GRANT EXECUTE ON FUNCTION public.upsert_product_with_parts TO anon;

GRANT EXECUTE ON FUNCTION public.upsert_product_with_parts TO authenticated;

GRANT EXECUTE ON FUNCTION public.upsert_product_with_parts TO service_role;

CREATE OR REPLACE FUNCTION public.process_purchase(p_purchase_items jsonb, p_parts_summary jsonb)
    RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_purchase_id bigint;
    v_total_cost numeric(10, 2) := 0;
    item jsonb;
    v_product_id bigint;
    v_quantity integer;
    v_price numeric(10, 2);
    v_part_id uuid;
    v_part_quantity numeric(10, 4);
BEGIN
    -- Start a transaction
    BEGIN
        -- Create the purchase record
        INSERT INTO public.purchases(total_cost, quantity)
            VALUES (0, 0)
        RETURNING
            id INTO v_purchase_id;
        -- Process each item in the order
        FOR item IN
        SELECT
            *
        FROM
            jsonb_array_elements(p_purchase_items)
            LOOP
                v_product_id :=(
                    SELECT
                        id
                    FROM
                        public.products
                    WHERE
                        uuid =(item ->> 'id')::uuid);
                v_quantity :=(item ->> 'quantity')::integer;
                IF v_product_id IS NULL THEN
                    RAISE EXCEPTION 'Product with uuid % not found',(item ->> 'id')::uuid;
                END IF;
                -- Get the product price and update stock
                UPDATE
                    public.products
                SET
                    quantity = quantity + v_quantity
                WHERE
                    id = v_product_id
                RETURNING
                    price INTO v_price;
                -- Update the total cost
                v_total_cost := v_total_cost +(v_price * v_quantity);
                -- Create purchase_products record
                INSERT INTO public.purchase_products(purchase_id, product_id, quantity)
                    VALUES (v_purchase_id, v_product_id, v_quantity);
            END LOOP;
        -- Update parts stock based on partsSummary
        FOR item IN
        SELECT
            *
        FROM
            jsonb_array_elements(p_parts_summary)
            LOOP
                v_part_id :=(item ->> 'id')::uuid;
                v_part_quantity :=(item ->> 'partsChange')::numeric(10, 4);
                UPDATE
                    public.parts
                SET
                    quantity = quantity + v_part_quantity
                WHERE
                    uuid = v_part_id;
                IF NOT FOUND THEN
                    RAISE EXCEPTION 'Part with uuid % not found', v_part_id;
                END IF;
                -- Create purchase_parts record
                INSERT INTO public.purchase_parts(purchase_id, part_id, quantity)
                    VALUES (v_purchase_id,(
                            SELECT
                                id
                            FROM
                                public.parts
                            WHERE
                                uuid = v_part_id), v_part_quantity);
            END LOOP;
        -- Update the total cost and quantity of the purchase
        UPDATE
            public.purchases
        SET
            total_cost = v_total_cost,
            quantity =(
                SELECT
                    SUM(quantity)
                FROM
                    public.purchase_products
                WHERE
                    purchase_id = v_purchase_id)
        WHERE
            id = v_purchase_id;
        -- Commit the transaction
        RETURN v_purchase_id;
    EXCEPTION
        WHEN OTHERS THEN
            -- Rollback the transaction in case of any error
            RAISE;
    END;
END;

$$;

-- Grant execute permission on the function
GRANT EXECUTE ON FUNCTION public.process_purchase TO anon;

GRANT EXECUTE ON FUNCTION public.process_purchase TO authenticated;

GRANT EXECUTE ON FUNCTION public.process_purchase TO service_role;

-- Create the process_sale function
CREATE OR REPLACE FUNCTION public.process_sale(p_sale_items jsonb)
    RETURNS integer
    LANGUAGE plpgsql
    SECURITY DEFINER
    AS $$
DECLARE
    v_sale_id integer;
    v_total_cost DECIMAL(10, 2) := 0;
    v_item jsonb;
    v_product_id integer;
    v_quantity integer;
    v_product_price DECIMAL(10, 2);
BEGIN
    -- Start a transaction
    BEGIN
        -- Create a new sale record
        INSERT INTO public.sales(total_cost)
            VALUES (0)
        RETURNING
            id INTO v_sale_id;
        -- Process each sale item
        FOR v_item IN
        SELECT
            *
        FROM
            jsonb_array_elements(p_sale_items)
            LOOP
                v_product_id :=(v_item ->> 'id')::integer;
                v_quantity :=(v_item ->> 'quantity')::integer;
                -- Get the product price and update the product quantity
                UPDATE
                    public.products
                SET
                    quantity = quantity - v_quantity
                WHERE
                    id = v_product_id
                RETURNING
                    price INTO v_product_price;
                IF NOT FOUND THEN
                    RAISE EXCEPTION 'Product with id % not found or insufficient quantity', v_product_id;
                END IF;
                -- Calculate the total cost for this item
                v_total_cost := v_total_cost +(v_product_price * v_quantity);
                -- Create sale_products record
                INSERT INTO public.sale_products(sale_id, product_id, quantity, price)
                    VALUES (v_sale_id,(
                            SELECT
                                id
                            FROM
                                public.products
                            WHERE
                                id = v_product_id), v_quantity, v_product_price);
            END LOOP;
        -- Update the total cost of the sale
        UPDATE
            public.sales
        SET
            total_cost = v_total_cost
        WHERE
            id = v_sale_id;
        -- Commit the transaction
        RETURN v_sale_id;
    EXCEPTION
        WHEN OTHERS THEN
            -- Rollback the transaction in case of any error
            RAISE;
    END;
END;

$$;

-- Grant execute permission on the function
GRANT EXECUTE ON FUNCTION public.process_sale TO anon;

GRANT EXECUTE ON FUNCTION public.process_sale TO authenticated;

GRANT EXECUTE ON FUNCTION public.process_sale TO service_role;

